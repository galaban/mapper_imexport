<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, June 03, 2015, 11:14 AM -->
<!-- MuClient version 4.98 -->

<!-- Plugin "Galabans_Mapper_ImportExport" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Galabans_Mapper_ImportExport"
   author="Galaban"
   id="1596a728a542a2e9194d43f4"
   language="Lua"
   purpose="Import and export the custom exits from the mapper database"
   save_state="y"
   date_written="2015-06-03 11:12:02"
   requires="4.80"
   version="1.0"
   >
<description trim="y">
<![CDATA[
This is an extension to the Aardwolf GMCP Mapper that will create an import and export functions for custom exits.

The command format is:
mapper export <filename>    -- export the custom exits from the mapper database
mapper import <filename>    -- import the custom exits from the mapper database

mapperexport help                  -- the help screen. (Not an ideal alias I know, but unavoidable
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   script="export_cexits_for_galaban"
   match="mapper export *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>
<aliases>
  <alias
   script="import_cexits_for_galaban"
   match="mapper import *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>

<aliases>
  <alias
   script="export_print_help"
   match="mapperexport help"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>


<!--  Script  -->


<script>
<![CDATA[

require("sqlite3")

-------
-- Help
-------

function export_print_help(name, line, wildcards, styles)
	local c_green = ANSI(22)..ANSI(32)

    local help_str = [[

This is an extension to the Aardwolf GMCP Mapper that will create an import and export functions for custom exits.

The command format is:
mapper export <filename>    -- export the custom exits from the mapper database
mapper import <filename>    -- import the custom exits from the mapper database

mapperexport help                  -- this help screen
]]
    print(help_str)

end

---------------------
-- Database Functions
---------------------
dbid = "mapper"

function openMapperDB(mode)
    local dbfile = GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"

    local retval = DatabaseOpen(dbid, dbfile, mode)   --read/write

    if (retval == sqlite3.OK) then
        return true
    elseif (retval == sqlite3.CANTOPEN) then
        Note("Unable to open the mapper database.")
        return false
    end
    Note("Unknown return code found while attempting to open the mapper database: "..retval)
    return false
end

function closeMapperDB()
    DatabaseClose(dbid)
end

function openMapperDB2(mode)
    local dbfile = GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"

    db = assert (sqlite3.open(dbfile))

end

function closeMapperDB2()
    db:close()
end


---------
-- Export
---------
function export_cexits_for_galaban(name, line, wildcards, styles)
	local c_white = ANSI(1)..ANSI(37)
	local c_grey = ANSI(22)..ANSI(37)
	local c_cyan = ANSI(1)..ANSI(36)
	local c_dcyan = ANSI(22)..ANSI(36)
	local c_blue = ANSI(22)..ANSI(34)
	local c_red = ANSI(1)..ANSI(31)
	local c_yellow = ANSI(1)..ANSI(33)
	local c_green = ANSI(1)..ANSI(32)

    ------------------------
    -- 1: Validate the input
    local filename = ""
    if (wildcards[1] ~= nil and wildcards[1] ~= "") then
        filename = sanitize_filename(Trim(wildcards[1]))
        
        local namelen = string.len(filename)
        -- oddly, -3 gets us the last 4 chars...
        if (namelen < 5 or (string.sub(filename, namelen-3) ~= ".csv")) then
            filename = filename..".csv"
        end

    end
    
    if (filename == "") then
        AnsiNote(c_red.."You must specify a valid filename for exporting.")
        export_print_help()
        return
    end

    ------------------------
    -- 2:  Open the files (database/csv), to make sure we can
    --filename = filename..".csv"

    local fullpath = GetInfo(66)..filename

    -- Try to open the database (read-only)
    if (openMapperDB(1) == false) then
        return
    end

    -- Try to open the file
    f = assert (io.open (fullpath, "w"),"Unable to open the file for writing")

    ------------------------
    -- 3:  Dump the database into the output file
    AnsiNote(c_grey.."Export custom exits...")

    local query = [[
        SELECT fromuid, touid, level, dir
        FROM exits 
        WHERE dir NOT IN ('n','s','e','w','d','u') 
        AND fromuid not in ('*','**') 
        ORDER BY fromuid
    ]]

	local status = DatabasePrepare(dbid, query)
    if (status ~= sqlite3.OK) then
        AnsiNote(c_red.."Error selecting from mapper database.  Returned value: "..status.." : "..DatabaseError(dbid))

        closeMapperDB()
        return
    end

    -- get the columns
    cols = DatabaseColumns (dbid)

    -- Loop through the recordset, writing out the values
    local count = 0
    rc = DatabaseStep (dbid)  
    while rc == sqlite3.ROW do
        count = count + 1
        values = DatabaseColumnValues (dbid)
        
        local lineout = ""
        for i = 1, cols do
            if (i > 1) then
                lineout = lineout..", "
            end
            if (i == 4) then
                lineout = lineout..fixsql(values [i])
            else
                lineout = lineout..values [i]
            end
        end -- for each column
        f:write(lineout.."\n")
        
        rc = DatabaseStep (dbid)
    end 

    -- Cleanup
    f:flush()
    f:close()

    AnsiNote(c_grey.."Wrote "..count.." custom exits to file: "..filename)

    DatabaseFinalize(dbid)

    closeMapperDB()

    AnsiNote(c_grey.."Export complete.")
end


---------
-- Import
---------
function import_cexits_for_galaban(name, line, wildcards, styles)
	local c_white = ANSI(1)..ANSI(37)
	local c_grey = ANSI(22)..ANSI(37)
	local c_cyan = ANSI(1)..ANSI(36)
	local c_dcyan = ANSI(22)..ANSI(36)
	local c_blue = ANSI(22)..ANSI(34)
	local c_red = ANSI(1)..ANSI(31)
	local c_yellow = ANSI(1)..ANSI(33)
	local c_green = ANSI(1)..ANSI(32)

    ----------------------
    -- Validate the inputs
    local filename = ""
    if (wildcards[1] ~= nil and wildcards[1] ~= "") then
        filename = Trim(wildcards[1])
    end
    
    if (filename == "") then
        AnsiNote(c_red.."You must specify a valid filename for exporting.")
        export_print_help()
        return
    end
    local fullpath = GetInfo(66)..filename

    -- Try to open the file
    f, errmsg, err_no = io.open (fullpath, "r")
    if err_no ~= nil then
        AnsiNote(c_red.."Unable to open the file for importing: "..errmsg)
        return
    end
    -- Try to open the database
    openMapperDB2()


    AnsiNote(c_grey.."Importing custom exits...")


    db:exec("BEGIN TRANSACTION")
    repeat
        s = f:read ("*l") -- read one line
        if (s ~= nil and s ~= "") then 
            local s_fromuid = ""
            local s_touid = ""
            local s_level = ""
            local s_cexit = ""

            s_fromuid, s = csvSplitOne(s)
            s_touid, s = csvSplitOne(s)
            s_level, s = csvSplitOne(s)
            s_cexit, s = csvSplitOne(s)

            -- Note that the cexit should come from the file ready to load into SQL
            local query = string.format ([[
                    INSERT OR REPLACE INTO exits (fromuid, touid, level, dir) 
                    VALUES (%s, %s, %s, %s)]],
                s_fromuid,
                s_touid,
                s_level,
                s_cexit)

            local code = db:exec(query)


            if code ~= sqlite3.OK and    -- no error
                code ~= sqlite3.ROW and   -- completed OK with another row of data
                code ~= sqlite3.DONE then -- completed OK, no more rows
                    local err = db:errmsg ()  -- the rollback will change the error message
                    err = err.."\nCODE: "..code.."\nQUERY: "..query.."\n"
                    db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
                    AnsiNote(c_red..err)
                    AnsiNote(c_grey.."Import failed.")
                    return
            end

        end
    until not s  -- until end of file

    db:exec("COMMIT")
    
    f:close ()  -- close that file now


    --AnsiNote(c_grey.."Wrote "..count.." custom exits to file: "..filename)

    --DatabaseFinalize(dbid)

    closeMapperDB2()
    
    AnsiNote(c_grey.."Import complete.")
end


--------------------
-- Utility Functions
--------------------
function sanitize_filename(str)
   str = string.gsub(str, "[^%w%s()_-%.]", "")
   return Trim(str)
end

function fixsql(s)
    if s then
        return "'" .. (string.gsub (s, "'", "''")) .. "'"
    else
        return "NULL"
    end
end

function csvSplitOne(fullstr)
    local splitstr = ""
    --  OK, I can hear it now:  "This is horribly slow, why didn't you use gmatch?!"
    --  The reason is because gmatch isn't powerful enough
    --  We need to be able to ignore commas when they are inside of a string
    --  Also, we need to be able to watch for escaped quotations ('By George, that''s a good idea')
    --  gmatch is not near powerful enough for that.

    if (fullstr == nil or string.len(fullstr) < 3) then
        return fullstr, ""
    end

    local haveString = false
    local splitstr = ""
    local peekChar = ""
    while string.len(fullstr) > 0 do
        local nextChar = string.sub(fullstr,1,1)
        fullstr = string.sub(fullstr,2)

        -- If we hit a comma outside of a string, that's it... the end.
        if(nextChar == "," and haveString == false) then
            return Trim(splitstr), fullstr
        end
        if(nextChar == "'" ) then
            if (haveString == false) then
                haveString = true
            else
                -- If our PeekChar is set, we were just looking at #2 of a double apostrophe
                -- Therefore, ignore this apostrophe (it's the same index as the peekChar)
                if (peekChar ~= "'") then

                    -- OK, we weren't just peeking, lets see if this is the end of the string
                    -- or if it's a double apostrophe
                    peekChar = string.sub(fullstr,1,1)

                    if (haveString == true and peekChar ~= "'") then
                        haveString = false
                    end
                else
                    -- Clear this out so that we know we've already looked at this (second) apostrophe
                    peekChar = ""
                end
            end
        end
        splitstr = splitstr..nextChar
    end

    --ran out of string... return this last item
    return Trim(splitstr), ""
end

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="Galabans_Mapper_ImportExport:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
